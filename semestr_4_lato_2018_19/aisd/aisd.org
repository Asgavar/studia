#+STARTUP: inlineimages showall

* Russian Peasant Multiplication
  - liczby a, b
  - a mnożymy przez 2, b dzielimy całkowicie przez 2
  - lepiej kiedy b < a, bo całość wykonuje tyle kroków ile potrzeba dzieleć żeby b = 1
  - opiera się na tym, że:
    - b parzyste => a * b = 2a * b/2
    - b nieparzyste => a * b = 2a * (b-1)/2 + a
  - http://mathforum.org/dr.math/faq/faq.peasant.html

* Kopiec
  - https://en.wikipedia.org/wiki/Heap_(data_structure)
  - http://pages.cpsc.ucalgary.ca/~boyd/331/heaps.html
  - https://medium.com/basecs/learning-to-love-heaps-cef2b273a238
  - klucze muszą pochodzić z uniwersum U uporządkowanego liniowo
  - tak naprawdę to drzewo binarne z paroma dodatkowymi cechami
  - kompletne drzewo, tj każdy level jest zapełniony (ew. poza ostatnim) - np. 2 synów w binarnym
  - ∀ v klucz(v) < klucz(ojciec(v))
  - implementacja na przykład na zwykłej tablicy jednowymiarowej.
    wtedy element k[i] ma swoje potomstwo w elementach k[2i] oraz k[2i + 1]
    #+ATTR_ORG: :width 500
    [[./img/heap-as-array.png]]
** Operacje
*** sift
**** sift-up
     - jeśli syn jest /większy/ od ojca => zamień ich miejscami.
       przejdź do ojca.
       jeśli nie, zakończ.
**** sift-down
     - jeśli syn jest /mniejszy/ od ojca => zamień ich miejscami i przejdź do ojca.
       jeśli jest mniejszy od obu => wybierz większego z potomków (inaczej mniejsze dziecko też zaburzyłoby heap property)
*** insert
    - znajdujemy najniższy level możliwie z lewej strony z wolnym miejscem i wsadzamy nowy node.
      jeśli heap property jest zachowany to spoko i kończymy, jeśli nie - zaczynamy sift-up
*** usunięcie korzenia
    - znajdujemy node na najniższym levelu z możliwie prawej strony i wsadzamy
      na miejsce usuniętego wcześniej korzenia. zaczynamy sift-down
*** zmiana wartości klucza
**** dekrementacja
     w minheapie może być konieczny sift-up, w maxheapie odwrotnie
**** inkrementacja
     analogicznie do ^, sift-down
*** heapify - budowa kopca ze zbioru kluczy
**** opcja naiwna
     wsadzamy każdy klucz po kolei i balansujemy w każdym kroku.
     wtedy złożoność to *O(nlogn)*, bo n kluczy i każdy balans zajmuje log(n) czasu.
**** opcja lepsza (aka Floyda)
     https://www.youtube.com/watch?v=MiyLo8adrWw
     budujemy kopce od dołu, zaczynając od liści i w każdym kroku tworząc kopce wyższe o jeden level.
     zaczynamy od przedostatniego poziomu (środka tablicy) i (być może) zamieniamy każdego hipotetycznego
     rodzica z jego większym (jeśli to max heap) dzieckiem.
     czas będzie liniowy dzięki lematowi:
     /~n/(2^k+1) wierzchołków znajduje się na wysokości k/
     *Σ(k * n/(2^k+1)*
     czyli *O(n)*.

* Heapsort
  *Θ(nlogn)*
  - formujemy odpowiedni kopiec z tablicy na wejściu - min lub max (*Θ(n)*)
  - wyciągamy najmniejszy/największy element (*Θ(logn)*) i tak *n* razy

* Priority Queue
** Operacje
*** find-max
*** delete-max
*** insert-node

* Min-Max Binary Heap
  - https://en.wikipedia.org/wiki/Min-max_heap
  - dwa kopce H, L połączone liścmi
  - H ma sufit(n/2) elementów, L podłoga(n/2)
  - H ma max w korzeniu, L ma min w korzeniu
  - kopiec do którego dokładamy wybieramy tak, by zachować ich rozmiary
  - można zapamiętać oba z nich w jednej tablicy
** Operacje
*** delete-min
*** delete-max
*** insert-node

* Sortowanie Topologiczne (znajdowanie porządku)
  - https://en.wikipedia.org/wiki/Topological_sorting
  - DAG
  - taki układ, że strzałki krawędzi idą zawsze w prawo
  - przykład: planowanie kolejności zadań do wykonania albo plików do kompilacji
    (przy uwzględnieniu zależności między nimi)
** Algorytm Kahna
   - obserwacja: każdy DAG ma wierzchołek o /indeg/ = 0
   - bierzemy taki wierzchołek (jeśli jest ich więcej to dowolny spośród nich)
   - wkładamy se na listę wynikową
   - patrzymy na wszystkich sąsiadów tego wierzchołka i zapisujemy, że ich /indeg/i
     właśnie zmniejszyły się o jeden
   - jeśli któryś z /indeg/ów sąsiadów spadł do zera to robimy z nim to samo
   - w każdym kroku będzie jakiś vertex o indeg = 0, bo DAG po wyjęciu wierzchołka
     dalej jest DAGiem
   - złożoność:
     - czas *O(n + m)*
     - pamięciowa *O(n)*

* Algorytmy zachłanne
  - tl;dr robimy coś co w danej chwili wydaje się najbardziej opłacalne
    i lecimy dalej
  - zazwyczaj najłatwiejsze do wymyślenia
  - dowody poprawności są schematyczne
  - najczęściej nie znajdują optymalnego rozwiązania xD
    ale czasem aproksymują
  - *Lemat o optymalnej podstrukturze*
  - examples
    - wydawanie reszty
      - wydajemy największą monetę której wartość nie przekracza reszty do wydania
      - i tak w kółko aż wydamy co do grosza
    - problem pani z dziekanatu xD
      - *N* - liczba osób
      - *Pi* - czas potrzebny na obsłużenie osoby /i/
      - *Ci* - wskaźnik niecierpliwości osoby /i/
      - rozwiązanie: sortujemy petentów po *Pi/Ci*

* Algorytmy 'dziel i zwyciężaj'
  - jeśli *n* jest trywialnie małe => po prostu rozwiąż problem
  - jak nie to:
    - podziel na /mniejsze/ podproblemy
    - rekursywnie rozwiąż każdy z nich
    - w jakiś sposób połącz te rozwiązania
  - examples
    - *Merge Sort*
    - *Quick Sort*
    - *Binary Search*
    - mamy tablicę o N elementach i:
      - /liderem/ nazywamy taki element, który występuje więcej niż *N/2* razy
      - jak znaleźć czy i jaki lider istnieje?
        - ciachamy tablicę na dwie części
        - szukamy lidera z lewej i z prawej
        - jak w którejkolwiek z nich nie ma lidera to elo, w całej tablicy też nie będzie
        - jeśli jest, to sprawdzmy, czy któryś z nich jest liderem w /całej/ tablicy
      - czas *Θ(nlogn)*
      - pamięć *Θ(logn)*

* Problem wyboru zadań aka odcinków na OX
  - konkretniej tak, żeby było ich jak najwięcej
  - sortujemy według współrzędnej/czasu końca (odcinka lub zadania) -> *O(nlogn)*
  - w każdym kroku wybieramy pierwsze, które zaczyna się po końcu ostatniego -> *Θ(n)*
  - razem *O/Θ(nlogn)* (zależy od algorytmu który sortuje)

* Greedy algorithm for Egyptian fractions
  - dostajemy liczbę a/b (ułamek zwykły)
  - chcemy zapisać ją jako 1/c + 1/d + ...
  - rozwiązanie zachłanne
    - bierzemy 1 / sufit z (b*a)
      - TODO
  - https://en.wikipedia.org/wiki/Greedy_algorithm_for_Egyptian_fractions
  - https://www.geeksforgeeks.org/greedy-algorithm-egyptian-fraction/

* Minimal Spanning Trees
  - drzewo o jak najmniejszej wadze, w którym wszystkie wierzchołki są osiągalne
** Cycle Property
   - bierzemy krawędź /e/. jeśli /e/ jest najcięższa na jakimś cyklu, 
     to nie może być częścią żadnego MST - w przeciwnym wypadku dałoby się trywialnie
     podmienić ją na jakąś lżejszą.
** Cut Property
   - TODO

* Set cover
  - https://en.wikipedia.org/wiki/Set_cover_problem
  - mamy zbiór (uniwersum) *U* oraz rodzinę jego podzbiorów *S*.
    (i jakąś funkcję, *c*, która wyznacza koszty S_1, S_2 itd.)
    chcemy znaleźć taki zbiór podzbiorów z S, że pokrywają U i
    są możliwie najtańsze.
    [[./img/set-cover-zachlanny.png]]

* Algorytm Karatsuby (mnożenia)
  TODO

* Twierdzenie o rekursji uniwersalnej
  TODO

* Sieci przełączników
** co to jest przełącznik?
