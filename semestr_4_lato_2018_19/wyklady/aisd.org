* Russian Peasant Multiplication
  - liczby a, b
  - a mnożymy przez 2, b dzielimy całkowicie przez 2
  - lepiej kiedy b < a, bo całość wykonuje tyle kroków ile potrzeba dzieleć żeby b = 1
  - opiera się na tym, że:
    - b parzyste => a * b = 2a * b/2
    - b nieparzyste => a * b = 2a * (b-1)/2 + a
  - http://mathforum.org/dr.math/faq/faq.peasant.html

* Kopiec
  - klucze muszą pochodzić z uniwersum U uporządkowanego liniowo
  - tak naprawdę to drzewo binarne z paroma dodatkowymi cechami
  - ∀ v klucz(v) < klucz(ojciec(v))
  - implementacja na przykład na zwykłej tablicy jednowymiarowej.
    wtedy element k[i] ma swoje potomstwo w elementach k[2i] oraz k[2i + 1]
** Operacje
*** zmiana wartości klucza
**** dekrementacja
     TODO
**** inkrementacja
     TODO
*** budowa kopca ze zbioru kluczy
**** opcja naiwna
     wsadzamy każdy klucz po kolei i balansujemy w każdym kroku.
     wtedy złożoność to *O(nlogn)*, bo n kluczy i każdy balans zajmuje log(n) czasu.
**** opcja lepsza
     zaczynamy od liści (końca tablicy) i balansujemy każdy klucz z hipotetycznym ojcem.
     wtedy *O(n)*.

* Heapsort
  *Θ(nlogn)*

* Priority Queue
** Operacje
*** find-max
*** delete-max
*** insert-node

* Podwójna PQ
  - dwa kopce H, L połączone liścmi
  - H ma sufit(n/2) elementów, L podłoga(n/2)
  - H ma max w korzeniu, L ma min w korzeniu
  - kopiec do którego dokładamy wybieramy tak, by zachować ich rozmiary
  - można zapamiętać oba z nich w jednej tablicy
** Operacje
*** delete-min
*** delete-max
*** insert-node
